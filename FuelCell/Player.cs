using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;

namespace FuelCell
{
    /// <summary>
    /// A player is a controllable entity in our game world that implements Super Mario 64-like controls
    /// with functional wall jumping and third person control.
    /// </summary>
    public class Player : ANode
    {
        private BoundingSphere InternalSphere;
        public new BoundingSphere Sphere
        {
            get
            {
                return InternalSphere.Transform(Matrix.CreateTranslation(Position));
            }
        }

        /// <summary>
        /// The currently active camera.
        /// </summary>
        public StaticCamera ActiveCamera;

        /// <summary>
        /// Camera to use when in third person mode.
        /// </summary>
        public OrbitCamera OrbitingCamera;

        /// <summary>
        /// Camera to use when in first person mode.
        /// </summary>
        public StaticCamera FirstPersonCamera;

        #region Gameplay Characteristics
        /// <summary>
        /// Movement multipliayer used for when crouching.
        /// </summary>
        public float CrouchSpeedMultiplier;

        /// <summary>
        /// How much adrenaline to drain per second when sprinting.
        /// </summary>
        public float AdrenalineDrain;

        /// <summary>
        /// What is the constant energy drain?
        /// </summary>
        public float AmbientEnergyDrain;

        /// <summary>
        /// The speed at which the camera will zoom in and out from Mario.
        /// </summary>
        public float ZoomSpeed;

        /// <summary>
        /// Where is the ground plane located for this character? This is some solid plane
        /// that the character cannot fall below.
        /// </summary>
        public float GroundPlane;

        /// <summary>
        /// What is the maximum speed we can yaw at?
        /// </summary>
        public float YawSpeed;

        /// <summary>
        /// What is the maximum speed we can pitch at?
        /// </summary>
        public float PitchSpeed;

        /// <summary>
        /// What is the maximum speed when we're walking?
        /// </summary>
        public float MaximumWalkSpeed;

        /// <summary>
        /// What is the maximum speed when we're sprinting?
        /// </summary>
        public float MaximumSprintSpeed;

        /// <summary>
        /// What is the maximum speed when we're in the air?
        /// </summary>
        public float MaximumAirControlSpeed;

        /// <summary>
        /// What is the strength of our jump? This determines not only the jump height
        /// but also the strength with which we jump towards a given direction.
        /// </summary>
        public float JumpStrength;

        /// <summary>
        /// The friction factor is a percentage to reduce the player velocity by per second
        /// when in contact with the ground.
        /// </summary>
        public float FrictionFactor;

        /// <summary>
        /// What is the height of the player? This is the height difference that the
        /// </summary>
        public float StandingHeight;

        /// <summary>
        /// What is the spin of our automatic spin when kicking off of walls?
        /// </summary>
        public float AutomaticSpinSpeed;

        /// <summary>
        /// The strength of any horizontal forces generated by a wall kick jump.
        /// </summary>
        public float WallkickStrength;

        /// <summary>
        /// The strength of any upward lift generated by a wall kick jump.
        /// </summary>
        public float WallkickLift;
        #endregion

        #region Object State
        /// <summary>
        /// Is the player currently crouched?
        /// </summary>
        public bool Crouched;

        /// <summary>
        /// The current adrenaline level.
        /// </summary>
        public float Adrenaline;

        /// <summary>
        /// Is the player currently in first person mode?
        /// </summary>
        public bool FirstPerson;

        /// <summary>
        /// A Vector3 representing the player's desired movement vector, relative to their own perspective.
        /// </summary>
        private Vector3 LocalStepVector;

        /// <summary>
        /// A Vector3 representing the player's desired movement vectorm, relative to the game world.
        /// </summary>
        private Vector3 WorldStepVector;

        /// <summary>
        /// What is the current gravity of our game world?
        /// </summary>
        public float Gravity;

        /// <summary>
        /// What is the current velocity of our player?
        /// </summary>
        public Vector3 Velocity;

        /// <summary>
        /// Are we currently sprinting?
        /// </summary>
        public bool Sprinting;

        /// <summary>
        /// What surface are we currently standing on?
        /// </summary>
        private Model Surface;

        /// <summary>
        /// What is our current energy level?
        /// </summary>
        public float Energy;
        #endregion

        /// <summary>
        /// What was the last surface we kicked off of?
        /// </summary>
        private Model LastKickoffSurface;

        /// <summary>
        /// What is the current spin we should apply to our character model?
        /// </summary>
        private float SpinApplication;

        /// <summary>
        /// The model to render for our character.
        /// </summary>
        private Model Character;

        /// <summary>
        /// Returns the current yaw angle of the player.
        /// </summary>
        public float ModelYaw
        {
            get
            {
                return Character.Rotation.Y;
            }
        }

        /// <summary>
        /// Helper property to determine whether or not the player is currently standing on any
        /// form of solid ground.
        /// </summary>
        public bool Grounded
        {
            get
            {
                Ray ray = new Ray(Sphere.Center, Vector3.Down);

                foreach (Model model in MapManager.MapBlocks)
                {
                    float? rayDist = ray.Intersects(model.CollisionBox);
                    if (rayDist != null)
                    {
                        float distance = (float)rayDist;

                        if (distance <= Sphere.Radius)
                            return true;
                    }
                }

                if (Position.Y <= GroundPlane || Surface != null)
                    return true;

                return false;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="game"></param>
        /// <param name="position">Position in game world.</param>
        /// <param name="target">Position to be looking up.</param>
        /// <param name="up">Orientation.</param>
        public Player(Game game, Vector3 position) : base(game)
        {
            Position = position;

            #region Camera Initialization
            OrbitingCamera = new OrbitCamera(game, this);
            FirstPersonCamera = new StaticCamera(game, Position, Vector3.Zero, Vector3.Up);
            ActiveCamera = OrbitingCamera;
            #endregion

            InternalSphere = new BoundingSphere(Vector3.Zero, 4f);

            #region Physical Characteristics Defaults
            Gravity = 250;
            JumpStrength = 150;
            WallkickStrength = 100;
            WallkickLift = 150;

            GroundPlane = 0.0f;
            FrictionFactor = 0.5f;
            StandingHeight = 13.5f;
            #endregion

            #region Gameplay Characteristics Defaults
            CrouchSpeedMultiplier = 0.5f;
            MaximumWalkSpeed = 1.0f;
            Energy = 100.0f;
            Adrenaline = 100.0f;
            AmbientEnergyDrain = 1.0f;
            AdrenalineDrain = 10.0f;
            MaximumSprintSpeed = 2;
            MaximumAirControlSpeed = 1.2f;

            YawSpeed = MathHelper.ToRadians(4);
            PitchSpeed = MathHelper.ToRadians(4);
            ZoomSpeed = 20.0f;
            #endregion

            AutomaticSpinSpeed = MathHelper.ToRadians(400);

            Character = new Model(game, "Shapes/Mario");
        }

        /// <summary>
        /// Update time pulse called every frame.
        /// </summary>
        /// <param name="time">
        /// Current snapshot of the game timing values.
        /// </param>
        public override void Update(GameTime time)
        {
            float deltaSeconds = (float)time.ElapsedGameTime.Milliseconds / 1000;

            float energyDrain = AmbientEnergyDrain;

            Energy -= energyDrain * deltaSeconds;

            if (Energy <= 0)
            {
                GUI.GUIManager.SetGUI("score");
                return;
            }

            Vector3 oldPosition = Position;
            Vector3 walkNormal = Vector3.TransformNormal(LocalStepVector, Matrix.CreateRotationY(Character.Rotation.X));

            if (Crouched)
                Character.Scale = new Vector3(1, 0.5f, 1);
            else
                Character.Scale = Vector3.One;

            if (walkNormal.X != 0 || walkNormal.Y != 0 || walkNormal.Z != 0)
            {
                float deltaYaw = (-OrbitingCamera.Yaw - MathHelper.PiOver2) - Character.Rotation.X;

                /*
                if (deltaYaw < 0)
                {
                    deltaYaw += YawSpeed * deltaSeconds;
                }
                else if (deltaYaw > 0)
                    deltaYaw -= YawSpeed * deltaSeconds;
                    */

                Character.Rotation += new Vector3(deltaYaw / 60.0f, 0, 0);
            }

            // Update Gravity & Position
            Velocity -= new Vector3(0, Gravity * deltaSeconds, 0);

            // Update velocity according to friction
            if (Grounded)
            {
                LastKickoffSurface = null;

                Velocity = new Vector3(Velocity.X - (Velocity.X * FrictionFactor),
                    Velocity.Y,
                    Velocity.Z - (Velocity.Z * FrictionFactor));
            }

            // Calculate what our walking forward vector is
            Vector3 forwardVector = new Vector3((float)Math.Sin(Character.Rotation.Y), 0, (float)Math.Cos(Character.Rotation.Y));
            Vector3 rightVector = Vector3.Cross(forwardVector, Vector3.Up);

            // If we're not grounded, multiply by air control speed, otherwise walking speed or sprinting speed.
            Vector3 walkVector = Vector3.Zero;

            Adrenaline = Adrenaline < 0 ? 0 : Adrenaline;

            float movementSpeed = 0;
            if (!Grounded)
                Velocity += walkNormal * MaximumAirControlSpeed;
            else if (Sprinting && Grounded && Adrenaline > 0)
            {
                movementSpeed = MaximumSprintSpeed;

                if (Crouched)
                    movementSpeed -= movementSpeed * CrouchSpeedMultiplier;

                walkVector = walkNormal * movementSpeed;

                Adrenaline -= AdrenalineDrain * deltaSeconds;
            }
            else if (Grounded)
            {
                movementSpeed = MaximumWalkSpeed;

                if (Crouched)
                    movementSpeed -= movementSpeed * CrouchSpeedMultiplier;

                walkVector = walkNormal * movementSpeed;
            }

            // Calculate our total move vector
            Vector3 finalizedMove = (Velocity * deltaSeconds) + walkVector;

            // Create a new step for each axis
            Vector3 xStep = new Vector3(finalizedMove.X, 0, 0);
            Vector3 yStep = new Vector3(0, finalizedMove.Y, 0);
            Vector3 zStep = new Vector3(0, 0, finalizedMove.Z);
            Vector3 xStepResult = Position + xStep;
            Vector3 yStepResult = Position + yStep;
            Vector3 zStepResult = Position + zStep;

            // Rotate the camera
            float yawMove = 0;

            // The character for some automatic spin
            if (SpinApplication != 0)
            {
                yawMove = SpinApplication < 0 ? -AutomaticSpinSpeed * deltaSeconds : AutomaticSpinSpeed * deltaSeconds;
                SpinApplication -= yawMove;

                if (SpinApplication < 0.5f && SpinApplication > -0.5f)
                   SpinApplication = 0;
            }
            Character.Rotation += new Vector3(yawMove, 0, 0);

            // Now we constrain to the walking plane if < GroundPlane
            if (Surface == null && Position.Y < GroundPlane && Velocity.Y < 0)
            {
                Velocity = new Vector3(Velocity.X, 0, Velocity.Z);
                Position = new Vector3(Position.X, GroundPlane, Position.Z);
            }
            else if (Surface != null && Position.Y < Surface.AbsoluteDimensions.Y && Velocity.Y < 0)
            {
                Velocity = new Vector3(Velocity.X, 0, Velocity.Z);
                Position = new Vector3(Position.X, Surface.AbsoluteDimensions.Y, Position.Z);
            }

            // We calculate various velocity normals to deter components where necessary.
            Vector3 velocityNormalX = new Vector3(Velocity.X, 0, 0);
            Vector3 velocityNormalY = new Vector3(0, Velocity.Y, 0);
            Vector3 velocityNormalZ = new Vector3(0, 0, Velocity.Z);

            velocityNormalX.Normalize();
            velocityNormalY.Normalize();
            velocityNormalZ.Normalize();

            // Process pickups
            List<Model> pickups = new List<Model>(MapManager.Pickups);
            foreach (Model pickup in pickups)
                if (pickup.Sphere.Intersects(InternalSphere.Transform(Matrix.CreateTranslation(Position))))
                    pickup.OnCollide();

            // After running the update, check if our camera collided
            BoundingSphere sphereStepX = InternalSphere.Transform(Matrix.CreateTranslation(xStepResult));
            BoundingSphere sphereStepY = InternalSphere.Transform(Matrix.CreateTranslation(yStepResult));
            BoundingSphere sphereStepZ = InternalSphere.Transform(Matrix.CreateTranslation(zStepResult));

            Model currentSurface = null;

            List<ANode> collidingList = new List<ANode>(MapManager.MapBlocks);
            foreach (Model collideTest in collidingList)
            {
                bool collided = false;

                Vector3 velocityNormal = Velocity;
                velocityNormal.Normalize();

                Ray velocityRay = new Ray(Sphere.Center, velocityNormal);
                float? rayDist = velocityRay.Intersects(collideTest.CollisionBox);
                bool heading = false;

                if (rayDist != null && (float)rayDist <= Sphere.Radius + 0.5f)
                    heading = true;

                if (collideTest.CollisionBox.Intersects(sphereStepX))
                {
                    xStep = Vector3.Zero;

                    if (heading)
                        Velocity = new Vector3(0, Velocity.Y, Velocity.Z);

                    if (!collided)
                        collideTest.OnCollide();

                    collided = true;
                }

                if (collideTest.CollisionBox.Intersects(sphereStepY))
                {
                    yStep = Vector3.Zero;

                  //  if (heading)
                    Velocity = new Vector3(Velocity.X, 0, Velocity.Z);

                    currentSurface = collideTest;

                    if (!collided)
                        collideTest.OnCollide();

                    collided = true;
                }

                if (collideTest.CollisionBox.Intersects(sphereStepZ) && velocityNormalZ.Length() != 0)
                {
                    zStep = Vector3.Zero;

                    if (heading)
                        Velocity = new Vector3(Velocity.X, Velocity.Y, 0);

                    if (!collided)
                        collideTest.OnCollide();

                    collided = true;
                }
            }

            Surface = currentSurface;

            // If our velocity is miniscule enough (<0.2f) then force it to 0
            if (Math.Abs(Velocity.X) < 0.2f)
                Velocity = new Vector3(0, Velocity.Y, Velocity.Z);
            if (Math.Abs(Velocity.Y) < 0.2f)
                Velocity = new Vector3(Velocity.X, 0, Velocity.Z);
            if (Math.Abs(Velocity.Z) < 0.2f)
                Velocity = new Vector3(Velocity.X, Velocity.Y, 0);

            Position += xStep;
            Position += yStep;
            Position += zStep;

            // Keep the camera in the game world
            Position = Position.X < 0 ? new Vector3(0, Position.Y, Position.Z) : Position;
            Position = Position.Z < 0 ? new Vector3(Position.X, Position.Y, 0) : Position;

            float maxX = MapManager.FloorTiles.X * 15;
            float maxZ = 2234;

            Position = Position.X > maxX ? new Vector3(maxX, Position.Y, Position.Z) : Position;
            Position = Position.Z > maxZ ? new Vector3(Position.X, Position.Y, maxZ) : Position;

            // Update Camera translation manually to our eye height
            Vector3 eyePosition = Position + new Vector3(0, StandingHeight, 0);
            FirstPersonCamera.View = Matrix.CreateLookAt(eyePosition, eyePosition + FirstPersonCamera.Direction, FirstPersonCamera.Up);

            Character.Position = Position;
            Character.Rotation += new Vector3(yawMove, 0, 0);

            OrbitingCamera.Update(time);

            if (FirstPerson)
                ActiveCamera = FirstPersonCamera;
            else
                ActiveCamera = OrbitingCamera;

            // Ensure that our character has an updated transform
            Character.UpdateTransformation();
        }

        #region Input Processing

        /// <summary>
        /// Listener method hooked to analog input events from the input manager. This is for controller stick input
        /// events and keyboard movement events are translated to here, as well.
        /// </summary>
        /// <param name="x">The current x state of user input.</param>
        /// <param name="y">The current y state of user input.</param>
        private void AnalogMovementListener(Vector2 input)
        {
            LocalStepVector = new Vector3(-input.X, 0, input.Y);
            WorldStepVector = Vector3.Transform(LocalStepVector, Matrix.CreateRotationY(OrbitingCamera.Yaw));
        }

        /// <summary>
        /// Called when the player attempts to zoom in.
        /// </summary>
        /// <param name="input">
        /// The percentage of zoom strength.
        /// </param>
        private void AnalogZoomListener(float input)
        {
            OrbitingCamera.OrbitDistance -= input * ZoomSpeed;
        }

        /// <summary>
        /// Called when the player attempts to zoom out.
        /// </summary>
        /// <param name="input">
        /// The percentage of zoom strength.
        /// </param>
        private void AnalogZoomoutListener(float input)
        {
            AnalogZoomListener(-input);
        }

        /// <summary>
        /// Listener method hooked to analog input events from the input manager. This is for controlled stick input
        /// events and mouse delta events.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        private void AnalogLookListener(Vector2 input)
        {
            if (InputManager.UseKeyboard && Mouse.GetState().LeftButton == ButtonState.Released)
                return;

            input = new Vector2(-input.X, input.Y);

            float newYaw = OrbitingCamera.Yaw + (input.X * YawSpeed);
            OrbitingCamera.Yaw = newYaw;
            float newPitch = OrbitingCamera.Pitch + (input.Y * PitchSpeed);
            OrbitingCamera.Pitch = newPitch;
        }

        /// <summary>
        /// Called when the player attempts to cycle the view on the player.
        /// </summary>
        /// <param name="pressed">
        /// True when the button is pressed, false when the button is released.
        /// </param>
        private void ToggleViewListener(bool pressed)
        {
            if (pressed)
                FirstPerson = !FirstPerson;
        }

        /// <summary>
        /// Called when the player attempts a jump.
        /// </summary>
        /// <param name="pressed">
        /// True when the button is pressed, false when the button is released.
        /// </param>
        private void JumpListener(bool pressed)
        {
            // Jump
            if (Grounded)
            {
                Vector3 jumpVector = new Vector3(WorldStepVector.X, JumpStrength, WorldStepVector.Z);
                jumpVector.Normalize();

                Velocity += (WorldStepVector * 20) + (jumpVector * JumpStrength);
            }
            else
            {
                BoundingSphere testSphere = InternalSphere.Transform(Matrix.CreateTranslation(Position));
                Vector3 forwardVector = new Vector3((float)Math.Sin(OrbitingCamera.Yaw), 0, (float)Math.Cos(OrbitingCamera.Yaw));
                Vector3 rightVector = new Vector3((float)Math.Sin(OrbitingCamera.Yaw - MathHelper.PiOver2), 0, (float)Math.Cos(OrbitingCamera.Yaw - MathHelper.PiOver2));

                // Here, we want to do some rays
                Ray[] rayCasts =
                {
                    new Ray(testSphere.Center + (-rightVector * Sphere.Radius), -rightVector),
                    new Ray(testSphere.Center + (rightVector * Sphere.Radius), rightVector),
                    new Ray(testSphere.Center + (-forwardVector * Sphere.Radius), -forwardVector),
                    new Ray(testSphere.Center + (forwardVector * Sphere.Radius), forwardVector),
                };

                float[] spinValues =
                {
                    MathHelper.ToRadians(-90),
                    MathHelper.ToRadians(90),
                    MathHelper.ToRadians(0),
                    MathHelper.ToRadians(190),
                };

                foreach (Model collideTest in MapManager.MapBlocks)
                {
                    // Can only do it once
                    if (collideTest == LastKickoffSurface)
                        continue;

                    float[] rayResults =
                    {
                        9999,
                        9999,
                        9999,
                        9999,
                    };

                    for (int rayIndex = 0; rayIndex < rayCasts.Length; rayIndex++)
                    {
                        float? rayResult = rayCasts[rayIndex].Intersects(collideTest.Sphere);

                        if (rayResult != null)
                            rayResults[rayIndex] = (float)rayResult;
                    }

                    for (int iteration = 0; iteration < 4; iteration++)
                        if (rayResults[iteration] < Sphere.Radius)
                        {
                            LastKickoffSurface = collideTest;

                            Velocity = Vector3.Zero;

                            Vector3 kickoffVector = -rayCasts[iteration].Direction * WallkickStrength;
                            Vector3 jumpVector = new Vector3(kickoffVector.X, kickoffVector.Y + WallkickLift, kickoffVector.Z);

                            Velocity += jumpVector;


                            SpinApplication = spinValues[iteration];

                            break;
                        }
                }
            }

        }

        /// <summary>
        /// Helper method to capture all sources of input for this player.
        /// </summary>
        /// <param name="enabled">
        /// Should the input be captured?
        /// </param>
        public void CaptureInput(bool enabled)
        {
            InputManager.MouseCapture = enabled;
            Game.IsMouseVisible = !enabled;

            if (enabled)
            {
                #region ControllerInput
                InputManager.RightStickListener = AnalogLookListener;
                InputManager.LeftStickListener = AnalogMovementListener;
                InputManager.AButtonListener = JumpListener;
                InputManager.RightShoulderListener = pressed => Sprinting = pressed;
                InputManager.LeftShoulderListener = pressed => Crouched = pressed;

                InputManager.LeftTriggerListener = AnalogZoomoutListener;
                InputManager.RightTriggerListener = AnalogZoomListener;
                #endregion

                #region KeyboardInput
                InputManager.SetKeyResponder(Keys.W, pressed => LocalStepVector = new Vector3(LocalStepVector.X, 0, pressed ? 1 : 0));
                InputManager.SetKeyResponder(Keys.S, pressed => LocalStepVector = new Vector3(LocalStepVector.X, 0, pressed ? -1 : 0));
                InputManager.SetKeyResponder(Keys.A, pressed => LocalStepVector = new Vector3(pressed ? -1 : 0, 0, LocalStepVector.Z));
                InputManager.SetKeyResponder(Keys.D, pressed => LocalStepVector = new Vector3(pressed ? 1 : 0, 0, LocalStepVector.Z));

                InputManager.SetKeyResponder(Keys.LeftShift, pressed => Sprinting = pressed);
                InputManager.SetKeyResponder(Keys.Tab, ToggleViewListener);
                InputManager.SetKeyResponder(Keys.Space, JumpListener);
                InputManager.SetKeyResponder(Keys.LeftControl, pressed => Crouched = pressed);
                InputManager.MouseDeltaListener = AnalogLookListener;
                InputManager.MouseWheelListener = AnalogZoomListener;
                #endregion
            }
            else
            {
                #region ControllerInput
                InputManager.RightStickListener = null;
                InputManager.LeftStickListener = null;
                InputManager.AButtonListener = null;
                InputManager.RightShoulderListener = null;
                #endregion

                #region KeyboardInput
                InputManager.SetKeyResponder(Keys.W, null);
                InputManager.SetKeyResponder(Keys.S, null);
                InputManager.SetKeyResponder(Keys.A, null);
                InputManager.SetKeyResponder(Keys.D, null);
                InputManager.SetKeyResponder(Keys.LeftShift, null);
                InputManager.SetKeyResponder(Keys.Space, null);
                InputManager.MouseDeltaListener = null;
                InputManager.MouseWheelListener = null;
                #endregion
            }
        }
        #endregion

        /// <summary>
        /// Determines whether or not this player collides with the given bounding sphere.
        /// </summary>
        /// <param name="col">
        /// The bounding sphere to check against.
        /// </param>
        /// <returns>
        /// True for if a collision occurred, false otherwise.
        /// </returns>
        public override bool Collides(BoundingSphere col)
        {
            return Sphere.Transform(Matrix.CreateTranslation(Position)).Intersects(col);
        }

        /// <summary>
        /// Called every frame to draw the player.
        /// </summary>
        /// <param name="effect">
        /// The basic effect to draw with.
        /// </param>
        public override void Draw(BasicEffect effect)
        {
            Character.Draw(effect);
        }
    }
}
